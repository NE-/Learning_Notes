<!--
  Author:  NE- https://github.com/NE-
  Date:    2022 September 30
  Purpose: C# Program Building Blocks
-->

# Members
- **Constants**: Constant values associated with the class.
- **Fields**: Variables that are associated with the class.
- **Methods**: Actions that can be performed by the class.
- **Properties**: Actions associated with reading and writing named properties of the class.
- **Indexers**: Actions associated with indexing instances of the class like an array.
- **Events**: Notifications that can be generated by the class.
- **Operators**: Conversions and expression operators supported by the class.
- **Constructors**: Actions required to initialize instances of the class or the class itself.
- **Finalizers**: Actions done before instances of the class are permanently discarded.
- **Types**: Nested types declared by the class.

# Accessibility
- **public**: Access isn't limited.
- **private**: Access is limited to this class.
- **protected**: Access is limited to this class or classes derived from this class.
- **internal**: Access is limited to the current assembly (.exe or .dll).
- **protected internal**: Access is limited to this class, classes derived from this class, or classes within the same assembly.
- **private protected**: Access is limited to this class or classes derived from this type within the same assembly.

# Fields
```c#
public class Color
{
  // Static fields only have one memory location
  // regardless of number of instances
  public static readonly Color Black = new(0, 0, 0);
  public static readonly Color White = new(255, 255, 255);
  public static readonly Color Red   = new(255, 0, 0);
  public static readonly Color Green = new(0, 255, 0);
  public static readonly Color Blue  = new(0, 0, 255);
    
  public byte R;
  public byte G;
  public byte B;

  public Color(byte r, byte g, byte b)
  {
    R = r;
    G = g;
    B = b;
  }
}
```
- `readonly` marks a field *read-only*. `readonly` assignment can only occur as part as field's declaration or in a constructor of same class.

# Methods
- Static methods only accessed through the class.
```c#
// Single expression syntax
public override string ToString() => "This is an object";
```

# Parameters
- **value**: passing input arguments. Copies.
  - Can specify default value.
- **reference**: passing arguments by reference. Must be variable with definite value.
  - Declared with `ref`.
- **output**: passing arguments by reference. Doesn't require explicit value assignment.
  - Declared with `out`.
- **parameter array**: variable number of arguments passed to method. Has to be last parameter.
  - Declared with `params`.
```c#
// Reference
static void Swap(ref int x, ref int y) { ... }

// Output
static void Divide(int x, int y, out int result, out int remainder) { ... }

// Parameter array
public static void Write(string fmt, params object[] args) { ... }
// Parameter array equivalent
int x=3, y=4, z=5;

string s = "x={0} y={1} z={2}";
object[] args = new object[3];
args[0] = x;
args[1] = y;
args[2] = z;
Console.WriteLine(s, args);
```

# Static and Instance Methods
- *Static methods* don't operate on a specific instance and can only directly access static members.
- *Instance methods* operates on specific instance and can access *both* static and instance members.

# Virtual, Override, and Abstract Methods
- Virtual method delcared and implemented in a base class where derived class may provide more specific implementation.
- Override method implemented in derived class that modifies the behavior of the base class' implementation.
- Abstract method declared in base class that **_must_** be overriden in all derived classes.
  - No definition in base class.
  - Declared with `abstract` modifier.
```c#
public abstract class Expression
{
  public abstract double Evaluate(Dictionary<string, object> vars);
}

public class Constant : Expression
{
  double _value;
  
  public Constant(double value)
  {
    _value = value;
  }
  
  public override double Evaluate(Dictionary<string, object> vars)
  {
    return _value;
  }
}

public class VariableReference : Expression
{
  string _name;
  
  public VariableReference(string name)
  {
    _name = name;
  }
  
  public override double Evaluate(Dictionary<string, object> vars)
  {
    object value = vars[_name] ?? throw new Exception($"Unknown variable: {_name}");
    return Convert.ToDouble(value);
  }
}

public class Operation : Expression
{
  Expression _left;
  char _op;
  Expression _right;
  
  public Operation(Expression left, char op, Expression right)
  {
    _left = left;
    _op = op;
    _right = right;
  }
  
  public override double Evaluate(Dictionary<string, object> vars)
  {
    double x = _left.Evaluate(vars);
    double y = _right.Evaluate(vars);
    switch (_op)
    {
      case '+': return x + y;
      case '-': return x - y;
      case '*': return x * y;
      case '/': return x / y;
          
      default: throw new Exception("Unknown operator");
    }
  }
}

// Usage
Expression e = new Operation(
  new VariableReference("x"),
  '+',
  new Constant(3));

// Usage 2
Expression e = new Operation(
  new VariableReference("x"),
  '*',
  new Operation(
    new VariableReference("y"),
    '+',
    new Constant(2)
  )
);
Dictionary<string, object> vars = new();
vars["x"] = 3;
vars["y"] = 5;
Console.WriteLine(e.Evaluate(vars)); // "21"
vars["x"] = 1.5;
vars["y"] = 9;
Console.WriteLine(e.Evaluate(vars)); // "16.5"
```

# Method Overloading
```c#
class OverloadingExample
{
  static void F() => Console.WriteLine("F()");
  static void F(object x) => Console.WriteLine("F(object)");
  static void F(int x) => Console.WriteLine("F(int)");
  static void F(double x) => Console.WriteLine("F(double)");
  static void F<T>(T x) => Console.WriteLine($"F<T>(T), T is {typeof(T)}");            
  static void F(double x, double y) => Console.WriteLine("F(double, double)");
  
  public static void UsageExample()
  {
    F();            // Invokes F()
    F(1);           // Invokes F(int)
    F(1.0);         // Invokes F(double)
    F("abc");       // Invokes F<T>(T), T is System.String
    F((double)1);   // Invokes F(double)
    F((object)1);   // Invokes F(object)
    F<int>(1);      // Invokes F<T>(T), T is System.Int32
    F(1, 1);        // Invokes F(double, double)
  }
}
```

# Other Function Members
```c#
// Example most common function members
public class MyList<T>
{
  const int DefaultCapacity = 4;

  T[] _items;
  int _count;

  public MyList(int capacity = DefaultCapacity)
  {
    _items = new T[capacity];
  }

  public int Count => _count;

  public int Capacity
  {
    get =>  _items.Length;
    set
    {
      if (value < _count) value = _count;
      if (value != _items.Length)
      {
        T[] newItems = new T[value];
        Array.Copy(_items, 0, newItems, 0, _count);
        _items = newItems;
      }
    }
  }

  public T this[int index]
  {
    get => _items[index];
    set
    {
      _items[index] = value;
      OnChanged();
    }
  }

  public void Add(T item)
  {
    if (_count == Capacity) Capacity = _count * 2;
    _items[_count] = item;
    _count++;
    OnChanged();
  }
  protected virtual void OnChanged() =>
    Changed?.Invoke(this, EventArgs.Empty);

  public override bool Equals(object other) =>
    Equals(this, other as MyList<T>);

  static bool Equals(MyList<T> a, MyList<T> b)
  {
    if (Object.ReferenceEquals(a, null)) return Object.ReferenceEquals(b, null);
    if (Object.ReferenceEquals(b, null) || a._count != b._count)
      return false;
    for (int i = 0; i < a._count; i++)
    {
      if (!object.Equals(a._items[i], b._items[i]))
      {
        return false;
      }
    }
    return true;
  }

  public event EventHandler Changed;

  public static bool operator ==(MyList<T> a, MyList<T> b) =>
    Equals(a, b);

  public static bool operator !=(MyList<T> a, MyList<T> b) =>
    !Equals(a, b);
}
```

# Constructors
- Instance constructor is a member that implements actions required to  initialize instance of a class.
- Static constructor is a member that implements actions required to initialize a class itself when it's first loaded.

# Properties
- Don't denote storage locations, instead they have accessors for reading or writing.
- Property with `get` and `set` is read-write, `get` only is read-only, `set` is write-only.
  - Can be declared static.
```c#
MyList<string> names = new();
names.Capacity = 100;   // Invokes set accessor
int i = names.Count;    // Invokes get accessor
int j = names.Capacity; // Invokes get accessor
```

# Indexers
- Member that enables objects to be indexed in the same way as an array.
- Name of member is `this` followed by parameter list written between `[]`.
```c#
MyList<string> names = new();
names.Add("Liz");
names.Add("Martha");
names.Add("Beth");
for (int i = 0; i < names.Count; i++)
{
  string s = names[i];
  names[i] = s.ToUpper();
}
```

# Events
- Member that enables class or object to provide notifications.
  - Declaration includes `event` keyword and type must be delegate.
```c#
class EventExample
{
  static int s_changeCount;
  
  // Event triggered when item added to list
  static void ListChanged(object sender, EventArgs e)
  {
    s_changeCount++;
  }
  
  public static void Usage()
  {
    var names = new MyList<string>();
    names.Changed += new EventHandler(ListChanged);
    names.Add("Liz");
    names.Add("Martha");
    names.Add("Beth");
    Console.WriteLine(s_changeCount); // "3"
  }
}
```

# Operators
- Member that defines the meaning of applying particular expression operator to instances of a class.
  - Unary, binary, and conversion operators.
  - All must be declared public and static.

# Finalizers
- Implements actions required to finalize an instance of a class.
- Needed to release unmanaged resources.
- Can't be invoked explicitly; invoked automatically during garbage collection.
- Unknown when and where they'll be invoked, therefore classes should only implement finalizers  only when no other solutions are feasible.

# Expressions
- Except for assignment and null-coalescing operators, all binary operators are *left-associative* (LtR).
- Assignment operators, null-coalescing (`?? ??=`), and conditional `?:` are *right-associative* (RtL).